# -*- coding: utf-8 -*-
"""abalationNew.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GlugHkg8pViK5sUNLGUW7p0Fjdx24mfR
"""

# Commented out IPython magic to ensure Python compatibility.
# -*- coding: utf-8 -*-
"""Final Copy of  Abalation-Final  .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cm0xHEXXt2XLyHpQYATOVF_TYSYwOXfo
"""

#from google.colab import drive
#drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
#!pip install optuna
#!pip install shap
#!pip install seaborn
import optuna as optuna
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import tensorflow as tf
import random
import os
import sys
import time
import seaborn as sns
from sklearn.metrics import accuracy_score, precision_score, recall_score, r2_score, mean_squared_error
from sklearn.model_selection import train_test_split, KFold
from tensorflow.keras import layers, losses
from tensorflow.keras.models import Model, Sequential, load_model
import tensorflow.keras as keras
import tensorflow.keras.backend as keras_backend
from tensorflow.keras.layers import BatchNormalization
from tensorflow.keras.layers import Activation, Dropout, Flatten, Input, Dense, concatenate 
from sklearn.feature_selection import mutual_info_regression
from numpy import asarray
#from transfertools.models import LocIT, CBIT
import math
import scipy
from numpy import arange
from numpy.random import rand
from matplotlib import pyplot
import matplotlib.pyplot as plt
from matplotlib.ticker import AutoMinorLocator
import matplotlib.pyplot as plt
from operator import add
#import optunann1
import optunannPOD
import subspacejsoptunaE
import xlsxwriter
from sklearn.preprocessing import StandardScaler, MinMaxScaler
#import optunanewtransformator_1
#taskArray = []
# Commented out IPython magic to ensure Python compatibility.
def top_x(df2,variable,top_x_labels):
  for label in top_x_labels:
    df2[variable+'_'+label] = np.where(df2[variable]==label,1,0)
  return df2

def converter(df1):
  df = df1
  k = 0
  for i in range(len(df.columns)):
    if df[df.columns[i]].dtypes == 'object':
      #print("String")
      uniqueValues0 = df[df.columns[i]].unique()
      title0 = df.columns[i]
      df = top_x(df, title0, uniqueValues0)
      #encoder = OneHotEncoder(handle_unknown='ignore')
      #encoder_df = pd.DataFrame(encoder.fit_transform(data[[data.columns[i]]]).toarray())
      #final_df = pd.concat([data,encoder_df],axis=1)
      #df.drop(title0, axis=1, inplace=True)
      #title0 = data.columns[i]
      #print(title0)
      #ar = {}
      #j=0
      #for s in uniqueValues0:
        #key, value = s, j+1
        #j = j+1
        #ar[key] = value
      #print(ar)
      #data = data.replace({title0: ar})
    else:
      k = k + 1
  return df



def deleter(df1):
  df = df1
  k = 0
  deleteList =[]
  for i in range(len(df.columns)):
    if df[df.columns[i]].dtypes == 'object':
      title0 = df.columns[i]
      deleteList.append(title0)  
  for i in range(len(deleteList)):
    df.drop(deleteList[i], axis=1, inplace=True)
  return df

def norm1(x, Y):
  return ((x - Y['min']) / ((Y['max']-Y['min'])+1e-60))
def normalization(x, x1):
  train_stats = x1.describe()
  train_stats = train_stats.transpose()
  return norm1(x, train_stats)

def compute_rse(y,yhat):
  #y = y.ravel()
  #yhat = yhat.ravel()
  mu = np.mean(y)
  return np.sqrt(np.sum((y-yhat)**2))/np.sqrt(np.sum((y-mu)**2))
def compute_smape(y,yhat):
  #y = y.ravel()
  #yhat = yhat.ravel()
  n = len(y)
  nr = np.abs(y - yhat)
  dr = 0.5*(np.abs(y) + np.abs(yhat))
  return (100./n)*np.sum(nr/dr)

def compute_mse(y, yhat):
  sq1 = tf.square(tf.subtract(yhat, y))
  sq1 = tf.reduce_mean(sq1)
  return sq1

if __name__ == "__main__":
  # Horovod: pin GPU to be used to process local rank (one GPU per process)
  #gpus = tf.config.experimental.list_physical_devices('GPU')
  #for gpu in gpus:
  #  tf.config.experimental.set_memory_growth(gpu, True)
  #if gpus:
  #  tf.config.experimental.set_visible_devices(gpus[hvd.local_rank()], 'GPU')
  os.chdir("../../../")
  use_msg = "Usage: " + sys.argv[0] + " input_filename"
  if len(sys.argv) < 2:
    print(use_msg)
    exit()
  #tf.debugging.set_log_device_placement(True)
  print("Num GPUs Available: ", len(tf.config.list_physical_devices('GPU')))
  #tf.debugging.set_log_device_placement(True)
  src_path = sys.argv[1] #"/content/drive//MyDrive/Pascal-BFS.csv" 
  tar_path = sys.argv[2] #"/content/drive/MyDrive/Turing-SSSP.csv"
  ep1 = int(sys.argv[3])
  trials1 = int(sys.argv[4])
  shot = sys.argv[5]
  fold = int(sys.argv[6])
  stdy = sys.argv[7]
  storageN = sys.argv[8]
  stdy2 = sys.argv[9]
  storageN2 = sys.argv[10]
  target_domain1 = sys.argv[11]
  size = int(sys.argv[12])
  target_label = sys.argv[13]
  test_split = float(sys.argv[14])
  val_split = float(sys.argv[15])
  rand_state = int(sys.argv[16])
  rand_state2 = int(sys.argv[17])
  result_path = os.getcwd()+sys.argv[18]
  model_path = os.getcwd()+sys.argv[19]
  chck_path = os.getcwd()+sys.argv[20]

  loader = dataLoader(src_path, tar_path)
  loader.loadData()
  #src_x, src_y, tar_x, tar_y = loader.getXY("ccgrid", None, "","teps",['graph_name','kernel_time','d2h_time','h2d_time','device','teps'])
  src_x, src_y, tar_x, tar_y = loader.getXY("", "",target_label)
  print("Src x shape before preprocessing")
  print(src_x.shape)
  print("Tar_x shape before preprocessing")
  print(tar_x.shape)
  #print(f"{tar_x.shape}, {tar_y.shape}")
  p = preprocessor(src_x, src_y, tar_x, tar_y, 0)
  p.preprocess()
  tar_x_scaled, tar_y_scaled = p.getTargetScaled()
  """# **Train Test validation**"""
  X_train, y_train, src_train, src_y_train, src_val, src_y_val, X_test, y_test = p.train_test_val( test_split, val_split, rand_state, rand_state2)
 
  #targetMetric1 = "ts"
  Lb = y_train
  lb = tar_y_scaled
  X = X_train
  Y = Lb
  x = tar_x_scaled
  y = lb
  print("Data pre processing done")
  #dataset = (tf.data.Dataset.from_tensor_slices((tf.cast(X, tf.float64), tf.cast(Y, tf.float64) )) )
  #dataset = dataset.repeat().shuffle(10000).batch(128)
  try:
    with tf.device('/gpu:0'):
      X1 = tf.convert_to_tensor(X, dtype = tf.float64)
      x1 = tf.convert_to_tensor(x, dtype = tf.float64)
      Lb1= tf.convert_to_tensor(Lb, dtype = tf.float64)
      lb1= tf.convert_to_tensor(lb, dtype = tf.float64)
      
      workbook = xlsxwriter.Workbook(f"/home1/08389/hcs77/{shot}-Results-with-subspace-1.xlsx")
      worksheet = workbook.add_worksheet()
      row = 0
      col = 0
      """
      nnparameters = optunannPOD.finder(X1, Lb1, epochs= ep1, checkpoint_path=f"/home1/08389/hcs77/{shot}/", num_of_trials=trials1, fold=10, stname=stdy, storageName = storageN)  #/content/MyDrive/SimpleNN/
      print("Neurons ")
      worksheet.write(row, col, nnparameters.params['neuron'])
      print(nnparameters.params['neuron'])
      print("Number of layers")
      worksheet.write(row, col+1, nnparameters.params['num_layers'])
      print(nnparameters.params['num_layers'])
      print("Learning rate")
      worksheet.write(row, col+2, nnparameters.params['lr2'])
      print(nnparameters.params['lr2'])
      print("Best Trial Number")
      worksheet.write(row, col+3, nnparameters.number)
      print(nnparameters.number)
      
      predictorModel = optunannPOD.create_model(neurons_input= int(nnparameters.params['neuron']), num_of_layers_1=int(nnparameters.params['num_layers']), lr= float(nnparameters.params['lr2']), actF="relu", lossF="mean_squared_error")
      """
      #predictorModel = optunannPOD.create_model(neurons_input= nuron_num, num_of_layers_1= num_layers, lr= lr_rate, actF="relu", lossF="mean_squared_error")
      #predictorModel.load_weights(f"/home1/08389/hcs77/{shot}/Trial-{nnparameters.number}-model")
      #predictorModel.layers[0].trainable = False
      #predictorModel.layers[1].trainable = False
      #results = open(f"/home1/08389/hcs77/Regressor-{shot}-results.txt", "a")
      #predictorModel.fit(X1, Lb1, epochs=1000)
      #predictorModel.save_weights(f"/home1/08389/hcs77/FAMDR/{shot}-model")
      #predictions = predictorModel.predict(X1)
      #model3, mse, mae, mape = kfoldValidation(model2, newX6, Lb1, 10, 100, 384)
      #model4, testMSE, testMAE, testMAPE = kfoldTesting(predictorModel, newx6, lb1, 10, 100, 384)
      
      print("1st target")
      #size = 5
      f = open(f"/home1/08389/hcs77/{shot}-{target_domain1}-indices.txt", "r")
      nums = f.readlines()
      index =0
      for i in range(5):
        fileI = open(f"{result_path}csv/Source-model-on-target-{target_app}-LP{num_of_frozen_layers}-results-{i}.csv", "w")
        writer = csv.writer(fileI)
        for j in range(1,10):
          indices = open(f"{result_path}indices/Source-model-on-target-{target_app}-LP-1-indices-{i}-{j}-percent.csv", "r" )
          dropIndices = []
          rowArr = []
          x2 =[]
          lb2 = []
          totallen = len(tar_x_scaled)
          loaded_indices = indices.readlines()
          z = 0
          for k in range(num_of_samples):
            #print(f"len of tar_x_scaled is now {len(tar_x_scaled)}")
            if readModeOn ==True:
              index =  int(loaded_indices[z]) #
            else:
              index = random.randint(0, totallen-1 ) #int(nums[i])
              indices.write(str(index))
              indices.write(" ")
              indices.write("\n")
              #print(index)
          dropIndices.append(index)
          z = z + 1
          x2.append(tar_x_scaled[index:index+1])
          lb2.append(tar_y_scaled[index:index+1])
          tar_x_scaled = np.delete(tar_x_scaled, index, 0)
          tar_y_scaled = np.delete(tar_y_scaled, index, 0)
          totallen -= 1
          indices.close()

          x2 = tf.convert_to_tensor( x2, dtype=tf.float64)
          lb2 = tf.convert_to_tensor( lb2, dtype=tf.float64)
          x2 = tf.reshape(x2, (x2.shape[0], x2.shape[2]))
          lb2 = tf.reshape(lb2, (lb2.shape[0], lb2.shape[2]))
          
          #predictorModel.fit(x2, lb2, epochs=50)
          
          subspace_parameters = subspacejsoptunaE.finder(X1, x2, Lb1, lb2, epochs=ep1, checkpoint_path=f"{chck_path}{target_app}-subspace/", num_of_trials=trials1, log_stepsP= 0, stname = stdy, storageName = storageN)        
          model = subspacejsoptunaE.Autoencoder(intermediate_dim=X1.shape[1], original_dim1=X1.shape[1], original_dim2=x2.shape[1], numOfLayers=subspace_parameters.params["num_layers"],neurons=subspace_parameters.params["neuron"], activation="relu")
          model.load_weights(f"/home1/08389/hcs77/subspace/{target_domain1}/{size}/{pos}/Loss Type-0-Trial-{subspace_representation6.number}-model")
          newX6 = model.getEncoded1(X1)
          newx6 = model.getEncoded2(tar_x_scaled)
        
          nnparameters = optunannPOD.finder(newX6, Lb1, epochs= ep1, checkpoint_path=f"{chck_path2}{target_app}-NN/" , num_of_trials=trials1, fold=10, stname = stdy2, storageName = storageN2)
          predictorModel = optunannPOD.create_model(neurons_input= int(nnparameters.params['neuron']), num_of_layers_1=int(nnparameters.params['num_layers']), lr= float(nnparameters.params['lr2']), actF="relu", lossF="mean_squared_error")
          predictorModel.fit(newX6, Lb1, epochs=1000, verbose=0)
          
         

          pred = predictorModel.predict(newx6)
          testMSE = mean_squared_error(tlb1, pred)
          testRSE = compute_rse(tlb1, pred)
          testSMAPE = compute_smape(tlb1, pred)
          print(f"{target_domain1}  mse is {testMSE}")
          print(f"{target_domain1} rse is {testRSE}")
          print(f"{target_domain1} smape is  {testSMAPE}")
          worksheet.write(row, col + 4, testMSE)
          worksheet.write(row, col + 5, testRSE)
          #worksheet.write(row, col + 6, testSMAPE)
          plt.figure(figsize=(10,10))
          plt.scatter(tlb1, pred)
          plt.savefig(f"/home1/08389/hcs77/{shot}-{target_domain1}-{size}-shot-{pos}-subspace.pdf")
          row = row + 1
          index = index +1 
        size = size + 5
      f.close()
      
      """
      print("2nd target")
      size = 5
      f = open(f"/home1/08389/hcs77/{shot}-{target_domain2}-indices.txt", "r")
      nums = f.readlines()
      index =0

      while size <= 15:
        for pos in range(3):
          col = 0
          worksheet.write(row, col, shot)
          worksheet.write(row, col + 1, target_domain2)
          worksheet.write(row, col + 2, size)
          worksheet.write(row, col + 3, pos)
          #predictorModel = optunannPOD.create_model(neurons_input= nuron_num, num_of_layers_1= num_layers, lr= lr_rate, actF="relu", lossF="mean_squared_error")
          #predictorModel.load_weights(f"/home1/08389/hcs77/{shot}/Trial-{trial_num}-model")
          #predictorModel.load_weights(f"/home1/08389/hcs77/CCGrid/{shot}-model ")
          #predictorModel.layers[0].trainable = False
          #predictorModel.layers[1].trainable = False
 
              


          x3 =[]
          lb3 = []
          dropIndices = []
          line = nums[index]
          #print("lines")
          #print(line)
          #print(x1.shape)
          # = data.dropna(axis=0)
          indices = line.split()
          for i in range(size):
            rI = int(indices[i])
            if tf.math.count_nonzero(xm[rI:rI+1])>0:
              x3.append(xm[rI:rI+1])
              lb3.append(lbm[rI:rI+1])
              dropIndices.append(rI)
          #print("before x2")
          #print(x2)
          x3 = tf.convert_to_tensor( x3, dtype=tf.float64)
          lb3 = tf.convert_to_tensor( lb3, dtype=tf.float64)
          x3 = tf.reshape(x3, (x3.shape[0], x3.shape[2]))
          lb3 = tf.reshape(lb3, lb3.shape[0])
          
          #predictorModel.fit(x3, lb3, epochs=50)
          
          td3 = data3_c.drop(labels=dropIndices, axis=0)
          tx3 = scaler.transform(td3)
          tx3 = tf.convert_to_tensor(tx3, dtype = tf.float64)
          tlb3 = mb.drop(labels=dropIndices, axis=0)
          tlb3 = tf.convert_to_tensor(tlb3, dtype = tf.float64)
           
          subspace_representation6 = subspacejsoptunaE.finder(X1, x3, Lb1, lb3, epochs=ep1, checkpoint_path=f"/home1/08389/hcs77/subspace/{target_domain2}/{size}/{pos}/", num_of_trials=trials1, log_stepsP=lossType, stname=stdy, storageName = storageN )
          model = subspacejsoptunaE.Autoencoder(intermediate_dim=X1.shape[1], original_dim1=X1.shape[1], original_dim2=x3.shape[1], numOfLayers=subspace_representation6.params["num_layers"],neurons=subspace_representation6.params["neuron"], activation="relu")
          model.load_weights(f"/home1/08389/hcs77/subspace/{target_domain2}/{size}/{pos}/Loss Type-{lossType}-Trial-{subspace_representation6.number}-model")
          newX6 = model.getEncoded1(X1)
          newx6 = model.getEncoded2t(tx3)

          nnparameters = optunannPOD.finder(newX6, Lb1, epochs= ep1, checkpoint_path=f"/home1/08389/hcs77/waste/", num_of_trials=trials1, fold=10, stname=stdy, storageName = storageN)
          predictorModel = optunannPOD.create_model(neurons_input= int(nnparameters.params['neuron']), num_of_layers_1=int(nnparameters.params['num_layers']), lr= float(nnparameters.params['lr2']), actF="relu", lossF="mean_squared_error")
          predictorModel.fit(newX6, Lb1, epochs=1000)


          pred2 = predictorModel.predict(newx6)
          testMSE2 = mean_squared_error(tlb3, pred2)
          testRSE2 = compute_rse(tlb3, pred2)
          testSMAPE2 = compute_smape(tlb3, pred2)
          print(f"{target_domain2} mse is {testMSE2}")
          print(f"{target_domain2} rse is {testRSE2}")
          print(f"{target_domain2} smape is {testSMAPE2}")
          worksheet.write(row, col + 4, testMSE2)
          worksheet.write(row, col + 5, testRSE2)
          worksheet.write(row, col + 6, testSMAPE2)
          plt.figure(figsize=(10,10))
          plt.scatter(tlb3, pred2)
          plt.savefig(f"/home1/08389/hcs77/{shot}-{target_domain2}-{size}-shot-{pos}.pdf")
          row = row + 1
          index = index + 1
        size = size + 5
      f.close()
      
      """
      """
      print("3rd target")
      size = 5
      f = open(f"/home1/08389/hcs77/{shot}-{target_domain3}-indices.txt", "r")
      nums = f.readlines()
      index =0
      while size <= 15:
        for pos in range(3):
          col = 0
          worksheet.write(row, col, shot)
          worksheet.write(row, col + 1, target_domain3)
          worksheet.write(row, col + 2, size)
          worksheet.write(row, col + 3, pos)
          #predictorModel = optunannPOD.create_model(neurons_input= nuron_num, num_of_layers_1= num_layers, lr= lr_rate, actF="relu", lossF="mean_squared_error")
          #predictorModel.load_weights(f"/home1/08389/hcs77/{shot}/Trial-{trial_num}-model")
          #predictorModel.load_weights(f"/home1/08389/hcs77/CCGrid/{shot}-model ")
          #predictorModel.layers[0].trainable = False
          #predictorModel.layers[1].trainable = False
          
          
          x4 =[]
          lb4 = []
          dropIndices = []
          line = nums[index]
          #print("lines")
          #print(line)
          #print(x1.shape)
          # = data.dropna(axis=0)
          indices = line.split()
          for i in range(size):
            rI = int(indices[i])
            if tf.math.count_nonzero(xn[rI:rI+1])>0:
              x4.append(xn[rI:rI+1])
              lb4.append(lbn[rI:rI+1])
              dropIndices.append(rI)
          #print("before x2")
          #print(x2)
          x4 = tf.convert_to_tensor( x4, dtype=tf.float64)
          lb4 = tf.convert_to_tensor( lb4, dtype=tf.float64)
          x4 = tf.reshape(x4, (x4.shape[0], x4.shape[2]))
          lb4 = tf.reshape(lb4, lb4.shape[0])



          predictorModel.fit(x4, lb4, epochs=50)
          
          td4 = data4_c.drop(labels=dropIndices, axis=0)
          tx4 = scaler.transform(td4)
          tx4 = tf.convert_to_tensor(tx4, dtype = tf.float64)
          tlb4 = nb.drop(labels=dropIndices, axis=0)
          tlbn = tf.convert_to_tensor(tlb4, dtype = tf.float64)
          

          subspace_representation6 = subspacejsoptunaE.finder(X1, x4, Lb1, lb4, epochs=ep1, checkpoint_path=f"/home1/08389/hcs77/subspace/{target_domain3}/{size}/{pos}/", num_of_trials=trials1, log_stepsP=lossType, stname=stdy, storageName = storageN)
          model = subspacejsoptunaE.Autoencoder(intermediate_dim=X1.shape[1], original_dim1=X1.shape[1], original_dim2=x4.shape[1], numOfLayers=subspace_representation6.params["num_layers"],neurons=subspace_representation6.params["neuron"], activation="relu")
          model.load_weights(f"/home1/08389/hcs77/subspace/{target_domain3}/{size}/{pos}/Loss Type-{lossType}-Trial-{subspace_representation6.number}-model")
          newX6 = model.getEncoded1(X1)
          newx6 = model.getEncoded2t(tx4)

          nnparameters = optunannPOD.finder(newX6, Lb1, epochs= ep1, checkpoint_path=f"/home1/08389/hcs77/waste/", num_of_trials=trials1, fold=10, stname=stdy2, storageName = storageN2)
          predictorModel = optunannPOD.create_model(neurons_input= int(nnparameters.params['neuron']), num_of_layers_1=int(nnparameters.params['num_layers']), lr= float(nnparameters.params['lr2']), actF="relu", lossF="mean_squared_error")
          predictorModel.fit(newX6, Lb1, epochs=1000)



          pred3 = predictorModel.predict(newx6)
          testMSE3 = mean_squared_error(tlbn, pred3)
          testRSE3 = compute_rse(tlbn, pred3)
          testSMAPE3 = compute_smape(tlbn, pred3)
          print(f"{target_domain3} mse is {testMSE3}")
          print(f"{target_domain3} rse is {testRSE3}")
          print(f"{target_domain3} smape is {testSMAPE3}")
          worksheet.write(row, col + 4, testMSE3)
          worksheet.write(row, col + 5, testRSE3)
          worksheet.write(row, col + 6, testSMAPE3)
          plt.figure(figsize=(10,10))
          plt.scatter(tlbn, pred3)
          plt.savefig(f"/home1/08389/hcs77/{shot}-{target_domain3}-{size}-shot-{pos}.pdf")
          row = row + 1
          index = index + 1
        size = size + 5
      f.close()
      """
      #pred3 = predictorModel.predict(xn)
      #mse = mean_squared_error(Lb1, predictions)
      #rse = compute_rse(Lb1, predictions)
      #smape = compute_smape(Lb1, predictions)
      #testMSE = compute_mse(pred, lb1)
      """
      testMSE = mean_squared_error(lb1, pred)
      testRSE = compute_rse(lb1, pred)
      testSMAPE = compute_smape(lb1, pred)
      testMSE2 = mean_squared_error(lbm, pred2)
      testRSE2 = compute_rse(lbm, pred2)
      testSMAPE2 = compute_smape(lbm, pred2)
      testMSE3 = mean_squared_error(lbn, pred3)
      testRSE3 = compute_rse(lbn, pred3)
      testSMAPE3 = compute_smape(lbn, pred3)
      """
      #print(f"Best trial number is {nnparameters.number}")
      #print(f"Source mse is {mse}")
      #print(f"Source mse is {rse}")
      #print(f"Source mse is {smape}")
      """
      print(f"Target mse is {testMSE}")
      print(f"Target rse is {testRSE}")
      print(f"Target smape is  {testSMAPE}")
      print(f"2nd target mse is {testMSE2}")
      print(f"2nd target rse is {testRSE2}")
      print(f"2nd target smape is {testSMAPE2}")
      print(f"3rd target mse is {testMSE3}")
      print(f"3rd target rse is {testRSE3}")
      print(f"3rd target smape is {testSMAPE3}")
      """
      
      #plt.figure(figsize=(10,10))
      #plt.scatter(Lb1, predictions)
      #plt.savefig(f"/home1/08389/hcs77/Source-{shot}-2.pdf")
      """
      plt.figure(figsize=(10,10))
      plt.scatter(lb1, pred)
      plt.savefig(f"/home1/08389/hcs77/target1-{shot}.pdf")
      plt.figure(figsize=(10,10))
      plt.scatter(lbm, pred2)
      plt.savefig(f"/home1/08389/hcs77/target2-{shot}.pdf")
      plt.figure(figsize=(10,10))
      plt.scatter(lbn, pred3)
      plt.savefig(f"/home1/08389/hcs77/target3-{shot}.pdf")
      """
      workbook.close()
    #print(f"Best trial number is {subspace_representation6.number}")
    #print(f"Source mse is {np.mean(mse)}")
    #print(f"Target mse is {np.mean(testMSE)}")
    
  except RuntimeError as e:
    print(e)
